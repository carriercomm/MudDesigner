using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Windows.Forms;

//MudEngine
using MudDesigner.MudEngine;
using MudDesigner.MudEngine.Attributes;
using MudDesigner.MudEngine.FileSystem;
using MudDesigner.MudEngine.Objects;
using MudDesigner.MudEngine.Objects.Environment;

namespace MudDesigner.Editors
{
    public partial class RoomDesigner : Form
    {
        internal bool IsEditingExisting = false;
        ZoneBuilder _ZoneBuilder;

        //Doorway currently loaded.
        Door _CurrentDoor;

        //Collection of plugins from within the 'plugins' folder
        List<System.Reflection.Assembly> _Plugins;

        public RoomDesigner(ZoneBuilder designer)
        {
            InitializeComponent();
            SetupEditor();
            _ZoneBuilder = designer;
        }

        public RoomDesigner()
        {
            InitializeComponent();
            SetupEditor();
        }

        private void SetupEditor()
        {
            //Initialize the Room & Doorway
            Program.Room = new Room();
            _CurrentDoor = new Door(AvailableTravelDirections.None);

            //This instances a copy of AvailableTravelDirections which is a list of
            //currently available directions users can travel within rooms.
            //Instead of updating the editor each time a new travel direction is implemented,
            //we simply build an array that contains each travel direction currently available
            //within the engine by getting each element from the AvailableTravelDirections enum
            BuildDoorwayList();

            //Load all of our plugin .dll files. This is the only directory not generated by
            //the engine, developers will need to manually create the folder if they want to
            //create plugins
            LoadPlugins();

            //Instance the scripting engine and set it up.
            Program.ScriptEngine = new ManagedScripting.ScriptingEngine();
            Program.ScriptEngine.Compiler = ManagedScripting.ScriptingEngine.CompilerSelections.SourceCompiler;
            Program.ScriptEngine.CompileStyle = ManagedScripting.Compilers.BaseCompiler.ScriptCompileStyle.CompileToMemory;
            Program.ScriptEngine.KeepTempFiles = false;

            //Show the user(s) the rooms properties
            propertyRoom.SelectedObject = Program.Room;
            txtScript.Text = Program.Room.Script;
        }

        private void BuildDoorwayList()
        {
            AvailableTravelDirections direction = new AvailableTravelDirections();

            //Build an array of travel directions currently implemented
            Array Values = System.Enum.GetValues(direction.GetType());

            //Loop through each travel direction within the array and add it
            //to the lstDirections listbox.
            foreach (int Value in Values)
            {
                string Display = Enum.GetName(direction.GetType(), Value);
                //The array contains a 'None' direction. As the editor will allow for
                //installing and uninstalling doorways, we don't need to show a 'None' direction
                //in the listbox.
                if (!Display.Equals("None"))
                    this.lstDirections.Items.Add(Display);
            }
        }

        private void LoadPlugins()
        {
            string pluginPath = System.IO.Path.Combine(Application.StartupPath, "Plugins");
            _Plugins = new List<System.Reflection.Assembly>();
            
            //Check if the plugin path exists.
            if (!System.IO.Directory.Exists(pluginPath))
                return;

            //Now loop through every .dll file in the plugins directory and load it into memory
            //A copy is stored within a collection for use later if needed.
            foreach (string assembly in System.IO.Directory.GetFiles(pluginPath, "*.dll"))
            {
                _Plugins.Add(System.Reflection.Assembly.LoadFile(assembly));
            }

            //TODO: Look for ways to allow Types to inherit from a Windows Control, and add each
            //control to a new tab or menu item, allowing for editor plugins as well.
        }

        /// <summary>
        /// Closes the editor.
        /// TODO: Serialize the Room out to file.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void btnCloseEditor_Click(object sender, EventArgs e)
        {
            this.Close();
        }

        /// <summary>
        /// Change the currently selected direction, allowing users to uninstall or install
        /// a doorway, and display the selected doorways properties for editing.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void lstDirections_SelectedIndexChanged(object sender, EventArgs e)
        {
            //Used to indicate that the direction the user selected exists,
            //and was found for editing
            bool IsFound = false;

            //Loop through each doorway installed within the Program.Room and see if the user has
            //selected a direction that belongs to a _CurrentDoor already created. If a _CurrentDoor with 
            //the selected direction is found, we display it's properties for editing instead
            //of creating a new _CurrentDoor and overwriting the previously created doorway.
            foreach (Door newDoor in Program.Room.InstalledDoors)
            {
                //Check if the current _CurrentDoor in the loop matches the currently selected
                //travel direction the user has selected in the listbox.
                if (newDoor.TravelDirection.ToString() == lstDirections.SelectedItem.ToString())
                {
                    //The travel directions match, let's set the current _CurrentDoor in the loop as our
                    //new selected doorway so that the user can edit it. 
                    _CurrentDoor = newDoor;

                    //Indicates that we found a matching doorway and have set it up for
                    //editing within the propertygrid
                    IsFound = true;

                    //Exit the loop
                    break;
                }
            }

            //There isn't a _CurrentDoor installed into the Program.Room yet with a travel direction
            //matching that of the users currently selected travel direction within the listbox.
            //so we instance a new _CurrentDoor
            if (!IsFound)
            {
                AvailableTravelDirections direction = GetDirection(lstDirections.SelectedItem.ToString());
                _CurrentDoor = new Door(direction);
            }
            //Display the properties for users to edit. This could be a pre-existing doorway
            //found within our loop, or a new doorway.
            propertyDoor.SelectedObject = _CurrentDoor;
        }

        /// <summary>
        /// Modified values within the doorway get stored within the currentDoor Field.
        /// </summary>
        /// <param name="s"></param>
        /// <param name="e"></param>
        private void propertyDoor_PropertyValueChanged(object s, PropertyValueChangedEventArgs e)
        {
            //Check if we are installing the door into the room or
            //uninstalling it from the current room.
            switch (_CurrentDoor.DoorState)
            {
                case Door.AvailableDoorStates.Installed:
                    InstallDoor();
                    break;
                case Door.AvailableDoorStates.Uninstalled:
                    UninstallDoor();
                    break;
            }
        }

        /// <summary>
        /// Converts a string into an AvailableTravelDirections enum equivilant if it
        /// exists within the enum list.
        /// </summary>
        /// <param name="Direction"></param>
        /// <returns></returns>
        private AvailableTravelDirections GetDirection(string Direction)
        {
            foreach (AvailableTravelDirections value in Enum.GetValues(typeof(AvailableTravelDirections)))
            {
                string name = value.ToString();

                if (name == Direction)
                    return value;
            }

            return AvailableTravelDirections.None;
        }

        /// <summary>
        /// Installs the _CurrentDoor into the Program.Room's collection of doorways
        /// </summary>
        private void InstallDoor()
        {
            //Indicates if we found a door already installed within the room
            //matching the selected travel direction.
            bool IsInstalled = false;

            //Incase there are no existing doors, the foreach loop gets skipped.
            if (Program.Room.InstalledDoors.Count == 0)
            {
                //Add the new door to the room
                Program.Room.InstalledDoors.Add(_CurrentDoor);
                return;
            }

            //Loop through all of the installed doors within this room and
            //check to see if we have a doorway with the same travel direction
            //that the user has selected within the list box. If so then we
            //need to prompt the user to ensure it's ok to overwrite the previous
            //door with a new door.
            foreach (Door newDoor in Program.Room.InstalledDoors)
            {
                if (newDoor.TravelDirection == _CurrentDoor.TravelDirection)
                {
                    Program.Room.InstalledDoors.Remove(newDoor);
                    Program.Room.InstalledDoors.Add(_CurrentDoor);
                    IsInstalled = true;
                    break;
                }
            }

            if (!IsInstalled)
                Program.Room.InstalledDoors.Add(_CurrentDoor);
        }

        /// <summary>
        /// Uninstalls the doorway from the room.
        /// </summary>
        private void UninstallDoor()
        {
            foreach (Door door in Program.Room.InstalledDoors)
            {
                if (door.TravelDirection == _CurrentDoor.TravelDirection)
                {
                    Program.Room.InstalledDoors.Remove(door);
                    break;
                }
            }
        }

        /// <summary>
        /// Resets the room.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void btnNewRoom_Click(object sender, EventArgs e)
        {
            DialogResult result = MessageBox.Show("Are you sure you want to create a new room?", "Room Designer", MessageBoxButtons.YesNo, MessageBoxIcon.Question);
            if (result == DialogResult.No)
                return;

            Program.Room = new Room();
            _CurrentDoor = new Door(AvailableTravelDirections.None);
            
            propertyDoor.SelectedObject = null;
            propertyRoom.SelectedObject = Program.Room;
        }

        private void btnSaveRoom_Click(object sender, EventArgs e)
        {
            string roomPath = FileManager.GetDataPath(SaveDataTypes.Rooms);
            string roomFile = System.IO.Path.Combine(roomPath, Program.Room.Filename);

            FileManager.Save(roomFile, Program.Room);

            if (!_ZoneBuilder.lstRooms.Items.Contains(Program.Room.Name))
                _ZoneBuilder.lstRooms.Items.Add(Program.Room.Name);

            Program.Zone.Rooms.Add(Program.Room);
            string zonePath = FileManager.GetDataPath(SaveDataTypes.Zones);
            string zoneFile = System.IO.Path.Combine(zonePath, Program.Zone.Filename);
            FileManager.Save(zoneFile, Program.Zone);
            this.Close();
        }

        private void tabControl1_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (tabObjects.SelectedTab.Text == "Script")
            {
                txtScript.Text = Program.Room.Script;
            }
        }

        private void btnCheckScript_Click(object sender, EventArgs e)
        {
            Program.ScriptEngine.Compiler = ManagedScripting.ScriptingEngine.CompilerSelections.SourceCompiler;
            Program.ScriptEngine.AddReference(Application.StartupPath + "/MUDEngine.dll");
          
            string code = "namespace MudDesigner.MudEngine.Objects.Environment\n"
                + "{\n"
                + "  public class " + Program.Room.Name.Replace(" ", "") + " : Room\n"
                + "  {\n"
                + "     " + txtScript.Text + "\n"
                + "  }\n"
                + "}\n";
            MessageBox.Show(Program.ScriptEngine.Compile(code), "Script Compiling", MessageBoxButtons.OK, MessageBoxIcon.Information);
        }

        private void txtScript_TextChanged(object sender, EventArgs e)
        {
            Program.Room.Script = txtScript.Text;
        }

        private void RoomDesigner_Load(object sender, EventArgs e)
        {
            if (IsEditingExisting)
            {
                string roomPath = FileManager.GetDataPath(SaveDataTypes.Rooms);
                string roomFile = System.IO.Path.Combine(roomPath, _ZoneBuilder.lstRooms.SelectedItem.ToString() + ".room");
                Program.Room = (Room)FileManager.Load(roomFile, Program.Room);
                propertyRoom.SelectedObject = Program.Room;
                txtScript.Text = Program.Room.Script;
            }
        }
    }
}
